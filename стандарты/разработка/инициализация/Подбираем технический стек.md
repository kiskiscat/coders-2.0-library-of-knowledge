Прежде чем погружаться в пучину разработки продукта, стоит определиться какой набор технологий будет использоваться, совместимы ли выбранные технологии друг с другом, хорошо ли они подходят для решения задач бизнеса и умеет ли команда ими пользоваться.

# Введение

В этой статье разберемся как можно подобрать технический стек, но прежде, стоит определиться с терминами и вводными данными.

### Определения

В общем случае, технический стек - это перечисление технологий, фреймворков, библиотек, инструментов используемых для разработки, запуска и поддержания продукта в рабочем состоянии. В случае web-приложений, продукты обычно состоят из кода запускаемого в браузере пользователя (клиентская часть) и кода запускаемого на серверах компании (серверная часть):

- **Клиентская часть** - обычно отвечает за пользовательский интерфейс, технический стек которой обычно называют frontend.
- **Серверная часть** - отвечает за выполнение бизнес-логики и взаимодействие с базами данных. Технический стек этой части называется backend.

Помимо этих частей бывают и другие:

- **Базы данных** тоже находятся в техническом стеке, так как от них зависят ограничения накладываемые на серверный код;
- **Инфраструктурный код** обслуживает деплой, миграции, отслеживание ошибок, отладку и автоматизированное тестирование;

После перечисления всех технологий системы можно добавить способы их взаимодействия друг с другом. Варианты связи frontend и backend обычно не зависят от выбора технологий, так как общение идет поверх HTTP:

1. Простой серверный рендинг;
2. SPA + HTTP-запросы(REST-like, Protobuf, JSON:API);
3. Дополнительный сервер для рендеринга (Next.js);
4. Backend-for-frontend;
5. WebSockets.

# Бизнес-логика

Так как скорость интернета и мощность мобильных устройств существенно выросли за последние 20 лет, все больше логики переезжает на клиентскую часть.

Конечно, бОльшая часть логики все еще может находиться на backend, но для этого нужно отправить запрос, заставить пользователя ждать ответа, затем вынуждать его читать ошибку и исправлять свой ввод.

С логикой на клиенте, пользователь может получить обратную связь куда раньше, не ожидая ответа сервера. Это вынуждает разработчиков частично дублировать бизнес-логику, а с другой стороны, backend может сфокусироваться на решении точечных задач, тогда как frontend будет вызывать меньше раз backend, больше выполняя манипуляций в браузере пользователя.

Из этого подхода выросли проекты вроде Firebase, Supabase, AppWrite. Когда backend становится довольно шаблонным web-сервером вокруг базы данных, а frontend сам определяет когда и куда записывать данные. Доступ при этом ограничивается с помощью возможностей базы данных и правил бизнес-логики.

А еще существуют web-приложения продолжающие корректную работу в offline, а это значит, что вся бизнес-логика должна быть в браузере пользователя.

# Важность правильного выбора

Для уже существующих проектов технический стек это лишь констатация факта, но для новых проектов возникает вопрос, какой стек использовать и почему. Технический стек может меняться, например потому что со временем меняются условия работы продукта, размер аудитории, частота посещений и т.д. Изменить стек в будущем можно, но это дополнительные затраты ресурсов и времени, которые должны быть оправданы.

Не бывает правильного или неправильного стека, так как продукты очень разные, то и стек может быть разным. Даже в рамках одного продукта может подойти разный стек. Здесь уместно говорить об оптимальности стека, нежели о мифической правильности.

Технический стек можно попробовать оценить по ряду параметров:

- **Эффективность разработки**: Оптимальный стек ускоряет разработку, улучшая производительность команды за счет использования знакомых инструментов. _Стоит сравнивать с временем разработки такой же средней фичи (1 story point) на другом стеке. Кроме этого, можно учитывать знакомство команды с технологиями в стеке, а также удобство их использования._
- **Масштабируемость**: Стек должен поддерживать рост приложения и изменение нагрузки. _Для оценки, здесь подойдет Roadmap продукта, чтобы прикинуть насколько легким будет добавление новых возможностей. С точки зрения производительности, можно провести нагрузочное тестирование конкретного стека в разных условиях._
- **Совместимость и поддержка**: Выбранные технологии должны хорошо взаимодействовать друг с другом и иметь развитые сообщества для поддержки. _Важно изучить совместимость технологий друг с другом, например некоторые фреймворки и библиотеки могут быть хуже совместимы с определенными базами данных или серверными решениями. Помимо совместимость, стоит оценить активность сообщества вокруг технологии и наличие понятной документации._

Неоптимальный стек может вызвать ряд проблем, которые могут серьезно повлиять на сроки запуска продукта, стоимость разработки, текучку кадров, сложность инфраструктуры и возможности для изменений.

Как обнаружить неоптимальный технический стек:

- **Неэффективность:** если команда разработчиков не знакома с технологиями в выбранном стеке, то потребуется время на обучение, поиск оптимальных решений и разработку;
- **Сложность интеграции:** технологии, интеграцию которых никто не проверял, могут плохо взаимодействовать друг с другом (пример: Cloudflare Workers + fastify).
- **Производительность:** некоторые фреймворки/сервера/библиотеки не справляются с большими объемами данных или высокой нагрузкой, что влияет на общую производительность. _Выявить конкретного виновника может быть очень сложно, если технологий в проекте очень много._
- **Масштабируемость:** в стеке могут быть технологии, масштабирование которых довольно сильно ограничено. _Лучше узнать об этом заранее, а не за два дня перед маркетинговой кампанией, и в панике мигрировать на другую технологию._
- **Трудности в поддержке:** не все open source проекты имеют достаточное сообщество или платную поддержку, поэтому в случае необходимости, экспертную помощь взять может быть неоткуда.
- **Устаревание:** технологии, которые не развиваются активно, могут привести к зависимости от устаревших версий программного обеспечения, что затрудняет внесение изменений, обновление зависимостей, а также исправление проблем безопасности.

# Анализ требований

Начать подбор технического стека стоит с анализа требований проекта. Придется продумать и определить фундамент, на котором будет строиться весь технический стек.

### Цели и масштабируемость

- **Определение ключевых целей.** В контексте web-приложений важно четко понимать какой именно проект необходимо разработать. Может быть вам подойдет SPA, или всё сложнее и Islands Architecture подойдет лучше? Каждый подход имеет особенности, которые влияют на выбор технологий.
- **Оценка пользовательской базы.** Собираетесь обслуживать 100, 10 тыс. или миллион пользователей? Как часто пользователи будут посещать приложение? Какие задачи решать? Для небольших проектов, монолит на Next.js может отлично сработать, в других случаях может подойти [astro.build](http://astro.build), а в третьих [vike.dev](http://vike.dev), может даже микрофронтенды.
- **Географический охват.** Если приложение будут открывать со всего мира, стоит задуматься о CDN и serverless. Будет ли отличаться интерфейс для пользователей из разных стран? Что на счет локализации? А если right-to-left?

### Производительность и безопасность

- **Оценка производительности.** Необходимо определить ключевые показатели, например Web Vitals, TTI (Time to Interactive) и FCP (First Contentful Paint). Например, для e-commerce проектов, на счету каждая секунда простоя.
- **Наличие realtime.** Крупным приложениям придется заранее продумать как любые события реального времени будут поступать во время потребителям. Здесь стоит прикинуть, будет ли достаточно периодического перезапроса, SSE (Server-Sent Events) или понадобятся WebSockets.
- **Безопасность данных.** Почти во всех проектах имеются чувствительные данные. Крайне важно зафиксировать какие это данные, какие сервисы получают к ним доступ, а также продумать как обезопасить данные от утечек. Возможно потребуется использовать Web Crypto API, а также какие-то библиотеки шифрования в браузере и на сервере.

### Бюджет и ресурсы

- **Ограничения бюджета.** Размер доступных финансов может повлиять не только на выбор платных инструментов, а также на количество времени доступного разработчикам. В некоторых случаях, это ограничение повлияет на архитектурные решения. Например, serverless может быть экономически выгоднее, для проектов с неравномерной нагрузкой.
- **Способности команды.** Стоит трезво оценивать навыки команды. Если основной костяк команды - сильные React-разработчики, вероятно, не стоит переходить на Vue/Svelte/Angular, только потому, что это модно. А если переход обоснован, то стоит учитывать время на адаптацию и поиск подходящих решений.
- **Дедлайны.** В случае большого запаса времени, можно заложить более сложную систему, чтобы облегчить возможности расширения проекта. Если _времени в обрез_, знакомый стек и готовые решения вроде NextAuth или Supabase ускорят запуск продукта.

### Долгосрочные перспективы

- **Расширяемость.** Стоит поразмышлять о том, как выбор технического стека повлияет на возможности расширения в будущем. Монолитная архитектура может быть быстрее в разработке в моменте, но в будущем внесение изменений большой командой может вызывать конфликты в PullRequest.
- **Тенденции индустрии.** Не менее важно следить за трендами, но применять их стоит разумно. Сейчас популярна архитектура Server Islands, но нужна ли она конкретному проекту? А что может принести использование WebAssembly?
- **Экосистема.** Технологии с активным сообществом и хорошей документацией вероятнее проживут дольше, тех, кто этих преимуществ не имеет. Это может быть критично, для долгосрочной поддержки проекта, особенно если технология закладывается в фундамент архитектуры.

### Заключение

В заключение хочу отметить, что анализ требований это не одноразовое действие, а итеративный процесс. По мере развития проекта, возникновения новых идей со стороны команды бизнеса, выхода на новые рынки, важно во время обнаруживать новые требования или изменения в существующих.

Проект должен быть готов к адаптации стека, но каждое изменение стоит обосновывать, а не следовать тренду, потому что модно. Тщательный анализ требований поможет избежать дорогостоящих ошибок в будущем, хоть и не даст 100% гарантии их отсутствия.

# Современный web-стек

В этом разделе будут описан не полный список доступных технологий. В действительности, каждый день появляется несколько новых фреймворков, инструментов и библиотек, какие-то заслуживают внимания, другие пока на слишком раннем этапе развития.

Помимо перечисленных технологий, стоит изучить альтернативы, в некоторых продуктах альтернатива может работать лучше.

### Typescript

Раньше существовал FlowType и ReasonML, сейчас по сути остался только Typescript. Некоторые рантаймы вроде Deno и Bun поддерживают typescript без необходимости сборки кода и даже установки компилятора tsc. В nodejs также появится поддержка запуска .ts файлов (уже доступна под флагом).

- **Статическая типизация.** Конечно, это не гарантия правильной работы кода, но от множества базовых ошибок защищает неплохо. Можно запускать проверку на этапе сборки проекта и узнавать об ошибках еще на локальной машине.
- **Developer Experience.** Автодополнение, объяснения и рефакторинг в IDE будут работать лучше, чем с обычным JavaScript.
- **Обратная совместимость.** Typescript позволяет постепенно переходить с javascript в уже существующих проектах. Можно начать с типизации в комментариях к коду.

Альтернатив особо нет.

### React

Лидер по вакансиям и открытым проектам в 2024 году.

- **Огромная экосистема.** Сотни библиотек решающих разнообразные задачи от декорирования компонентов, до календарей и Drag’n’drop элементов. К тому же, существуют headless библиотеки компонентов и наборы React Hooks, чтобы упростить реализацию проекта.
- **Компонентный подход.** В отличие от других фреймворков (например Astro), компоненты React это чаще всего функции, которые не требуют специального обращения. Это позволяет коду быть компактнее за счет гибкости React.
- **Виртуальный DOM.** В современной frontend-разработке, это скорее минус, чем плюс, но в отличие от Vue или Svelte, React позволяет выполнять операции над DOM-элементами, что улучшает developer experience, хоть и может усложнить кривую входа для новичков.
- **Гибкость.** С одной стороны фреймворки вроде Vue, Angular диктуют правила как структурировать код, а с другой они накладывают существенные ограничения на архитектуру. Next.js страдает теми же проблемами. Чистый React позволяет выбирать разные фреймворки и архитектуры, а в случае необходимости реализовать свой подход.

В качестве самой близкой альтернативы существуют Preact и Solid. Стоит изучить и полностью другие фреймворки: Angular, Vue, Svelte.

### Effector

Относительно новый стейт-менеджер, создан в русскоговорящем сообществе разработчиков, но уже имеет экосистему: роутер, библиотеку операторов, кеш запросов, биндинги к фреймворкам. Направлен на решение задач современых web-приложений, с множеством событий и сайд-эффектов.

- **Декларативность.** Позволяет описывать бизнес-логику не смешивая её с логикой компонентов в виде последовательных шагов читаемых сверху вниз.
- **Типобезопасность.** Имеет полную поддержку TypeScript из коробки. Использует не самые очевидные возможности языка для улучшения developer experience.
- **Масштабируемость.** За счет композируемости позволяет справляться даже с крупными приложениями. Фабрики значительно упрощают переиспользование кода с бизнес-логикой.
- **Тестируемость.** Каждая фабрика может быть протестирована, так как легко создать инстанс фабркии и проверить именно его, независимо от других инстансов.

Здесь выбор богаче, в качестве самой близкой альтернативы MobX и mobx-state-tree.

А если смотреть на менее гибкую, но более популярную библиотеку: Redux, Zustand, и другие классические менеджеры состояния.

### Vite

Современный и быстрый сборщик проектов. Является основой многих мета-фреймворков: Remix, Vike, Astro. Де-факто стандарт для сборки SPA.

- **Быстрый запуск сервера.** Vite использует нативные ES-модули в браузере для dev-сервера, это значит, что предварительный бандлинг не требуется. Но если файлов в проекте очень много, браузеру может понадобиться время для загрузки всех модулей.
- **Экосистема rollup.** Vite построен поверх rollup и esbuild, что позволяет использовать сотни уже готовых рабочих плагинов.
- **Простота.** Конфигурация Vite обычно не больше 30 строк, половина из которых это отступы и скобки. При необходимости, можно гибко настроить сборку, так как поддерживаются .cjs, .esm, .ts форматы конфигов.

На самом деле сборщиков довольно много, стоит хотя бы ознакомиться с ними: Webpack, ESBuild, Parcel, MicroBundle, TurboPack.

Помимо сборщиков есть инструменты преобразования кода из одного синтаксиса в друго: Babel, SWC, TypeScript Compiler, Sucrase.

# Современный backend-стек

### Node.js

При необходимости, в стеке может присутствовать серверная часть на JavaScript. Это например: Backend for Frontend, Server Side Rendering, etc. В этом случае встает вопрос выбора рантайма для запуска, которых сейчас довольно много: **nodejs**, **deno**, **bun**. У всех немного отличаются режимы работы и поддерживаемые API.

К тому же, не стоит забывать о serverless, таких как AWS lambda, AWS lambda edge, CloudFlare Workers, Vercel Edge, Supabase Edge Functions, и т.д. Количество поддерживаемых API может отличаться еще сильнее.

### Supabase

Пакет из 5 крупных фич, построенных вокруг реляционной базы данных **PostgreSQL**: аутентификация, база данных, хранение файлов, обновления реального времени, serverless-функции. Защита данных осуществляется через PostgreSQL Row Level Security.

- **Масштабируемость.** Можно использовать supabase запущенный на серверах компании, можно поднять свои инстансы, даже запустить локально. Коробочное решение имеет готовую к production конфигурацию, в том числе резервные копии, проверки прав доступа и т.д.
- **Готовый API.** В случае supabase нет потребности поднимать еще один web-сервер, который будет транслировать обращения frontend в запросы к БД и отдавать отформатированные результаты. Благодаря пакету supabase-js, можно запрашивать данные напрямую из frontend-части вашего приложения, в комплекте идет полная типизация запросов, ORM и куча удобного API сверху.
- **Открытый исходный код.** В любой момент можно предложить изменения, нововведения или исправления в исходный код Supabase на Github. Таким образом, баги могут быть быстро исправлены не только командой Supabase, что добавляет стабильности проекту.

Помимо SQL-based баз данных существует еще ряд вариантов:

- Key-Value (KV)

  - **Redis.** Используется для кэширования и хранения данных в памяти, что обеспечивает высокую скорость доступа. Подходит для приложений, требующих быстрой обработки данных.
  - **Amazon DynamoDB.** Удобно масштабируется и подходит для работы с большими объемами данных.

- Документо-ориентированные (NoSQL)

  - **MongoDB.** Хранит данные в формате JSON-подобных документов, что позволяет легко работать с неструктурированными данными. Подходит для приложений с гибкой схемой.
  - **CouchDB.** Использует JSON для хранения данных и JavaScript для обработки запросов.

- Графовые

  - **Neo4j.** Оптимизирована для работы с графами, что позволяет эффективно хранить и обрабатывать сложные взаимосвязи между данными.
  - **ArangoDB.** Универсальная база данных, которая поддерживает графовые, документо-ориентированные и KV-модели данных.

- Колоночные

  - **Apache Cassandra.** Спроектирована для обработки больших объемов данных с высокой доступностью и масштабируемостью.
  - **HBase.** Построена на Hadoop и предназначена для хранения больших объемов данных в распределенной среде.

- Объектно-ориентированные

  - **db4o.** Хранит объекты в их нативном формате, что позволяет разработчикам работать с данными, как с объектами.

# Контроль качества кода

Времена, когда разработчики спорили о том, как форматировать код уже давно прошли. Сейчас разработчики спорят о том, какой общедоступный формат принимать, какие инструменты использовать и в каких случаях.

- **Prettier.** Стандарт для автоматического форматирования js, ts, jsx, css, json, md, vue, html. Имеет не очень много настроек, плагины для расширения возможностей и поддержки новых форматов.
- **ESLint.** Инструмент проверки кода на типичные ошибки. Имеет огромную экосистему правил упакованных в наборы (preset) для разных случаев. Может автоматически исправлять некоторые ошибки.
- **Stylelint.** Как ESLint, но для CSS. Имеет широкую экосистему из разных вариаций CSS (Sass). Проверяет и исправляет самые разные ошибки, может сортировать свойства и селекторы для удобства и наглядности.
- **Husky.** Инструмент запуска задач во время работы с Git. Например, позволяет запускать проверку и форматирование кода перед git commit. Еще зачастую используется для запуска тестов перед git push. В общем случае, подойдет любой адаптер git hooks для frontend-проектов.

В качестве замены большинства инструментов можно рассмотреть **Biome**. Запускать задачи можно так же с помощью **TurboRepo**.

# Тестирование

Долгое время мастодонтом тестирования в javascript проектах был **Jest**: мощный и богатый инструмент для запуска тестов и проверки результатов. Имеет тонну плагинов, умеет запускать End-to-end помимо unit-тестов.

В 2024 году популярность набирает **Vitest**, который выпустил полноценную версию v2.0 и теперь претендует на место Jest, так как работает быстрее, имеет поддержку Vite из коробки, без необходимости настраивать сразу два инструмента и не имеет некоторых _родовых травм_ Jest.

Для unit-тестирования React-компонентов стоит рассмотреть **React Testing Library**. Библиотека способствует написанию тестов, которые имитируют взаимодействие пользователя с приложением, это помогает писать надежные тесты, что в свою очередь влияет на устойчивость кода.

Для интеграционного тестирования есть несколько вариантов, все они позволяют запустить приложение в браузере и проводить полный цикл тестов приложения, буквально нажимая на кнопки и отслеживая изменения URL. Наиболее гибкий сейчас - **Playwright**. Кроме него стоит посмотреть на очень популярный Cypress и Puppeteer.

Playwright имеет ряд преимуществ:

- **Широкая поддержка браузеров.** Поддерживает Chromium, Firefox, Webkit с помощью единого API. Возможность протестировать приложения сразу в куче браузеров, на разных разрешениях экрана и все без постоянной реконфигурации.
- **Инструменты отладки.** Playwright предоставляет инструменты вроде Inspector и Trace Viewer для пошагового исполнения тестов, что крайне облегчает анализ проблем и ошибок.
- **Не только JavaScript.** Писать тесты можно еще и на TypeScript, Python, Java и C#, что значит, Playwright может стать универсальным инструментом тестирования web-продуктов.

# Интеграция

Прежде чем переходить к реализации, стоит оценить совместимость разных компонентов технического стека друг с другом.

### Взаимодействие frontend-backend

При наличии в стеке мобильного или десктопного приложения, стоит заранее определить какие функции выполняет Web, а какие Mobile. Чаще всего можно свести потребности Web и Mobile к единому API.

Для общения по HTTP существует целый ряд протоколов или инструментов для его построения:

1. OpenAPI/Swagger для описания REST-like методов сервера;
2. Protobuf в качестве протокола общения;
3. JSONRPC или JSONAPI для выполнения удаленных процедур;

Для отслеживания изменения в режиме реального времени чаще всего используются WebSockets. Чтобы описывать существующие каналы, а также структуру сообщений, можно использовать AsyncAPI. Это OpenAPI для event-driven взаимодействий.

### Совместимость компонентов стека

Прежде чем строить продукт на стеке технологий, стоит проверить совместную работу самых критических компонентов. Особенно, если в документации не указано, что авторы или сообщество уже проверяли совместимость. К сожалению, даже если кто-то проверил совместную работу разных технологий, нет гарантий, что в новом проекте всё заработает без проблем.

В зависимости от наличия времени и ресурсов, проверку стоит делать более глубокой. Даже если времени почти нет, стоит собрать минимальный прототип, который не будет включать в себя полезных функций, но при этом проверит интеграцию нескольких технологий. Такой прототип позволит обнаружить проблемы на самых ранних этапах и пересмотреть технический стек.

Постепенно добавляя технологии/фреймворки/библиотеки/инструменты в проект прототипа, можно удостовериться, что весь стек совместим. Получившийся код можно использовать для формирования заготовки под полноценный проект, не повторяя весь процесс снова.

Если у команды есть достаточно времени на подготовку, можно сделать прототип с несколькими полезными функциями и провести нагрузочное тестирование. Результатом будет явное представление о возможностях стека в определенных условиях. Можно будет прикинуть количество необходимых серверов, возможные пути оптимизации и сильные стороны стека.

### Безопасность

Редкий продукт не хранит никаких данных пользователей. Всё же, чаще можно встретить продукты, главная ценность которых - это данные, а значит данные необходимо защищать от несанкционированного доступа.

Как минимум стоит ознакомиться с самыми серьезными способами навредить web-проектам:

1. **Инъекции.** SQL, NoSQL, LDAP и прочие виды атак, позволяющие сторонним лицам встраивать команды в запросы. Про SQL-инъекции слышно больше всего, поэтому стоит почитать как их избежать.
2. **Нарушение контроля доступа.** Этот тип уязвимости позволяет сторонним лицам получить доступ к функциям, которые не закладывались разработчиками продукта. Например, возможность удалять чужие блог-посты, хотя с точки зрения бизнес-логики не должны бы.
3. **Отсутствие безопасности в дизайне.** В случае, если архитектура проекта не подразумевает безопасной передачи пользовательских данных, злоумышленник может получить доступ только к части системы, а затем используя уязвимости в архитектуре получить доступ ко всей системе целиком.
4. **Ошибки аутентификации.** На данный момент существуют протоколы OAuth2 и расширение OpenID Connect, позволяющие реализовать безопасный доступ к данным пользователя через авторизацию. В том числе, OAuth2 зачастую используется для аутентификации пользователя через доверенную сторону, например соц.сеть. Не стоит придумывать свои протоколы аутентификации взамен существующим, если в команде нет специалиста по безопасности.
5. **Уязвимые зависимости.** С 2020 года было случилось несколько “интернет-драм” с опасными npm-пакетами. Стоит регулярно проверять и обновлять зависимости в вашем стеке. Авторы активных проектов регулярно исправляют уязвимости. Команда `npm audit` даст некоторые подсказки, что стоит обновить в первую очередь.
6. **Отсутствие логгирования.** Без логов и мониторинга проблем невозможно вовремя обнаружить атаку и отреагировать на неё. Важно настроить алерты/репорты критических ситуаций.
7. **Мошенничество с запросами между сайтами.** Злоумышленники могут от имени пользователя выполнять несанкционированные действия. В некоторых случаях, пользователь может даже не догадываться о том, что от его имени выполняются действия.
8. **XSS.** Злоумышленники могут вставлять в поля и URL различной опасности скрипты, которые могут исполняться в браузере других пользователей и выполнять несанкционированные действия.

По безопасности web-приложений можно выпустить целую серию книг. Большие объемы информации не должны пугать, стоит сфокусироваться на самых популярных и опасных уязвимостях. К тому же, в зависимости от особенности ведения бизнеса, выбранной архитектуры и стека могут появляться новые возможности для атаки. Стоит закладывать безопасность еще на этапе планирования.

# Заключение

Выбор технического стека для современных web-проектов требует баланса между популярностью и надежностью. Далеко не все популярные open source проекты можно назвать надежными и стабильными. Важно выбирать такие технологии, которые не только обладают самыми модерновыми возможностями, но и проверены временем компаниями в продакшене.

Решающее значение имеет именно взгляд на долгосрочную перспективу. Важно проанализировать, как изменения в бизнесе, рост количества пользователей и/или новые требования к безопасности могут повлиять на архитектуру приложения, а также, что команда может предпринять. Таким образом выбор технического стека может быть более обоснованным.

Чем более независимы архитектурные компоненты, тем легче их можно будет заменить в будущем. Реализовать независимость поможет спецификация всех взаимодействий между компонентами. Стек должен быть достаточно гибким, чтобы позволить внедрить изменения без серьезных изменений архитектуры. В мире frontend-разработки, технологии постоянно меняются, обновлять критические зависимости и мигрировать на другие приходится довольно часто.

# Ссылки и статьи

- [Choosing the Right Technology Stack for Your Web or Mobile Development Project | Moqod Blog](https://moqod.com/blog/the-right-technology-stack-for-your-project)
- [Choosing the Right Technology Stack: The Heartbeat of a Successful Project](https://www.linkedin.com/pulse/choosing-right-technology-stack-heartbeat-successful-project-brown/)
- [Choosing the Right Tech Stack for Startup: Success Startup Guide](https://cyaniclab.com/blogs/choosing-the-right-tech-stack-for-startup)
- [How to Choose the Right Tech Stack for Your Project in 2024 | Make IT Simple](https://www.makeitsimple.co.uk/blog/how-to-choose-tech-stack-for-your-project)
- [What to focus on when choosing a tech stack? Detailed guide](https://syndicode.com/blog/how-to-choose-tech-stack/)
- [JS Toolbox 2024 Part 3: Bundlers and test frameworks](https://medium.com/@raygunio/js-toolbox-2024-part-3-bundlers-and-test-frameworks-c60f55f26920)
- [Decoding JavaScript Transpilers: A Babel & Its Alternatives](https://codewithsharma.medium.com/babel-the-javascript-compiler-57f081e9124a)
- [Vitest](https://vitest.dev/)
- [Example | Testing Library](https://testing-library.com/docs/react-testing-library/example-intro/)
- [Playwright vs Puppeteer vs Cypress vs Selenium (E2E testing) | Better Stack Community](https://betterstack.com/community/comparisons/playwright-cypress-puppeteer-selenium-comparison/)
- [Home 2024 - OpenAPI Initiative](https://www.openapis.org/)
- [JSON:API - A specification for building APIs in JSON](https://jsonapi.org/)
- [JSON-RPC](https://www.jsonrpc.org/)
- [OpenAPI Specification - Version 3.1.0 | Swagger](https://swagger.io/specification/)
- [Protocol Buffers](https://protobuf.dev/)
- [www.asyncapi.com](http://www.asyncapi.com)
