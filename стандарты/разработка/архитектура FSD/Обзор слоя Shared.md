В этом уроке подробно разберем устройство Shared слоя, какие у него есть составные части, правила формирования, а также особенности.

# API

Сегмент API в слое Shared позволяет сформировать кодовую базу для общения со всеми внешними сервисами, например с бекендом приложения.

Основные принципы:

1. Свести хранение состояния в этом слое к минимуму. Чем меньше глобального состояния нам нужно отслеживать, тем лучше.
2. Слой Shared можно рассматривать как глобальное основание нашего приложения. Все остальные слои будут обращаться к этому базовому слою, стоит покрыть его тестами и документацией.
3. Внутри слоя Shared мы имеем сегменты, а не слайсы, так как они обладают собственной структурой и не повторяют внутреннюю структуру.

### Традиционный подход vs подход FSD

Зачастую, множество библиотек и гайдов предлагают очень упрощенные подходы по выполнению запросов, в том числе размещение их прям в `useEffect`, что приводит к многочисленным и болезненным рефакторингам.

##### Распространенные рекомендации

Размещать описание API-запросов там, где они используются. То есть, класть их прямо в компоненты, страницы, виджеты или хуки.

Это работает для простых административных панелей, где данные и рендеринг тесно связаны.

##### В каких случаях это не работает

1. Когда приложение взаимодействует с несколькими backend/провайдерами.
2. Если приложение имеет сложную внутреннюю логику (offline-first, например).
3. Команда планирует поддерживать приложение дольше одного года.
4. Когда backend развивается (например, переход с REST на GraphQL, или с v1 на v2).

### Преимущества централизованных API-запросов

1. **Защита от изменений backend**

   - Если структура backend ответов меняется, нужно менять код только в одной директории.
   - Это предотвращает необходимость изменения кода по всему приложению, во всех местах, где запрос используется.

2. **Переиспользование кода**

   - Один и тот же запрос может использоваться в разных местах.
   - Избегается дублирование кода.
   - Легче тестировать и поддерживать.

3. **Преобразование данных**

   - Backend часто предоставляет данные сразу для множества клиентов, не всегда в удобном формате для вашего приложения.
   - Cегмент API позволяет преобразовывать данные от backend в удобный внутренний формат приложения.
   - Это защищает код приложения от внешних изменений: как бы внешние провайдеры не менялись, основную логику приложения менять нет необходимости.

# Публичный API

Рекомендуется не импортировать из глубоко вложенных файлов, вместо этого стоит экспортировать только необходимые объявления через `index.ts`.

1. **Назначение**

   - Защищает остальную часть приложения от изменений внутренней структуры.
   - Предоставляет стабильный интерфейс для других слоев.

2. **Правила экспортов**

   - Не используйте wildcard экспорты (`export * from`).
   - Явно указывайте, что должно быть экспортировано.
   - Подход помогает предотвращать случайное раскрытие внутренней реализации.

3. **Сложности**

   - В случае некоторых сборщиков, такие barrel-файлы могут увеличивать размер бандла.
   - Некоторые IDE при автоматическом импорте, предпочитают не index-файлы, а оригинальные более длинные пути.

### Реализация запросов

Что обычно требуется от библиотеки выполнения запросов:

- Обработка базового пути
- Форматирование поисковых параметров
- Форматирование тела запроса
- Управление заголовками
- Обработка ошибок
- Парсинг ответа

### Зачем создавать собственную обертку для запросов?

1. **Соображения по объему**

   - Собственная обертка: ~30 строк кода.
   - Популярные библиотеки: 50+ КБ.
   - Обычно всё равно требуется писать код поверх обертки для:

     - установки базового URL;
     - управления заголовками;
     - работы с токенами;
     - обработки ошибок;
     - парсинга ответа.

2. **Гибкость**

   - Можно настроить под конкретные нужды.
   - Легче модифицировать и поддерживать.
   - Лучший контроль за обработкой ошибок.

# Организация файлов

### Структура директории API

1. Группируйте запросы по разным файлам, если их очень много.
2. Отделяйте запросы от библиотеки выполнения запросов, чтобы избежать коллизии имен.
3. В случае глубокой вложенности модулей с запросами, создавать index-файл для каждой директории не востребовано.
4. Генерируйте файлы с запросами из openapi/swagger, если это возможно.

### Валидация данных

Со стороны веб-приложения, рекомендуется не доверять ответам backend и проверять их во время работы на соответствие ожидаемым структурам.

1. **Рантайм-валидация**

   - Используйте валидаторы, такие как Zod или RunTypes.
   - Валидируйте ответы от бэкэнда даже в production.

2. **Обработка ошибок**

   - Отправляйте ошибки валидации в сервисы мониторинга.
   - Держите одинаковые сборки для разных окружений.

# Init и Config

Продолжаем изучение слоя Shared в Feature-Sliced Design. Мы уже разобрались с сегментом shared/api, обсудили преимущества публичного API для каждого сегмента, и теперь переходим к следующему аспекту - конфигурации и инициализации приложения.

Сегмент shared/config отвечает за хранение всей глобальной конфигурации приложения, как статической, так и динамической, а shared/init обеспечивает последовательную инициализацию всех необходимых процессов при старте приложения.

### Сегмент Config

Это сегмент, в котором хранится вся глобальная конфигурация приложения, как статическая (например, базовые настройки приложения, такие как API URL, таймауты запросов, имена ключей), так и динамическая (например, feature-флаги, пользовательские настройки темы, текущие параметры окружения).

Сегмент **Config** может включать как статическую, так и динамическую конфигурацию. Например, если приложение поддерживает смену тем, то все настройки темы, включая пользовательские предпочтения, могут быть реализованы здесь.

В случае effector, можно экспортировать `Store<T>`, чтобы снаружи было доступно только чтение. В этом случае рекомендуется минимизировать количество логики изменяющей значение сторов.

Основные рекомендации:

- Используйте файл **index.ts** для объявления Public API всей конфигурации. Это помогает изолировать детали реализации и минимизировать возможные ошибки при изменениях в именах переменных, а также снизить влияние структуры конфигурации на работу приложения.
- Рекомендуется присваивать значения переменных окружения конкретным константам внутри сегмента shared/config, чтобы минимизировать количество точек изменения в коде.
- Для статической конфигурации можно использовать рантайм валидацию вырезаемую во время сборки. Этот подход облегчит отладку в случае некорректной конфигурации после `git clone` или же на CI.

### Сегмент Init

Это сегмент, предназначенный для обработки этапов инициализации приложения. Обычно здесь объявляются события, для согласованного выполнение различных фаз инициализации по всему приложению.

В больших приложениях может быть несколько фаз инициализации, не линейный порядок запуска логики в модулях, поэтому здесь можно экспортировать функции для создания объектов инициализации.

В самом простом случае сегмент shared/init состоит из событий, которые обозначают различные фазы инициализации приложения. Например, процесс загрузки конфигурации может подписаться на событие `configLoadingStarted` перед тем, как продолжить инициализацию, а затем вызывать `configLoadingFinished`.

Такое разделение упрощает поддержку и делает процесс инициализации предсказуемым. Чаще всего в этом сегменте есть только файл **index.ts**, который экспортирует нужные функции и события.

# Lib и UI

Мы продолжаем исследовать слой Shared в Feature-Sliced Design, и в этом видео основное внимание будет уделено сегментам shared/lib и shared/ui. Эти сегменты обеспечивают поддержку переиспользуемых внутренних библиотек и компонентов, формируя базу для построения логики и интерфейса приложения.

### Сегмент Lib

Это сегмент, в котором хранятся все внутренние библиотеки проекта. Содержимое этого сегмента можно нарезать на слайсы, а также разрешено импортировать из других сегментов Shared (API, Config, Init, etc), но при этом чем меньше зависимостей, тем лучше.

```tsx
shared/
  lib/
    <lib-name>/
      index.ts
      functional-group.ts
      functional-group.test.ts
```

- **Изоляция и Чистота**: Старайтесь максимально изолировать код внутри shared/lib, чтобы уменьшить зависимости от других сегментов. Меньше внешних зависимостей - проще тестировать и переиспользовать библиотеки, что делает их более надёжными и долговечными. Такая изоляция облегчает тестирование и переиспользование библиотек.
- **Структура и Подходы**: Внутренняя структура библиотеки может быть любой, главное - простота и прозрачность. Организовывайте код так, чтобы он был легким для понимания и последующей поддержки. Оформляйте библиотеки так, будто Вы публикуете их в NPM-реестр.
- **index.ts и Public API**: Всегда используйте **index.ts** для описания публичного API. Это позволяет рефакторить и изменять внутреннюю структуру без влияния на зависимый код.

##### Поддержка

- **Покрытие тестами**: Каждая важная функция должна быть покрыта тестами, что обеспечит стабильность и легкость внесения изменений в будущем. Стремитесь к высокому качеству тестов и к полноте покрытия, чтобы повысить надёжность Shared слоя
- **Документация JSDoc**: с помощью JSDoc стоит описывать назначение и смысл аргументов функций и классов, чтобы при использовании библиотеки из shared/lib не приходилось читать реализацию.

##### Структура

- **Сгруппированные функции**: Создавайте общие файлы для функций, которые имеют схожее назначение. Создавать по одному файлу на функцию зачастую неудобно, так как невыгодно увеличивает размер библиотеки.
- **Тестовые файлы**: В некоторых случаях, для корректного тестирования нужны отдельные файлы, в которых выполняется конфигурация или мок, такие файлы не должны экспортироваться через **index.ts**, чтобы они оставались внутренними и могли быть изменены без опасений.

### Сегмент UI

Это внутренняя библиотека компонентов, содержащая базовые элементы интерфейса, которые переиспользуются по всему проекту. Это базовые строительные блоки проекта, своего рода "Lego", из которого строятся все более сложные элементы, на более высоких слоях.

Для организации компонентов можно использовать подход **Atomic Design**, который делит компоненты на атомы, молекулы, организмы и шаблоны. Этот подход позволяет группировать компоненты по уровню их сложности и переиспользуемости. Здесь поведение групп похоже на поведение слоев, Организмы состоят из Молекул и Атомов.

- **Атомы**: Простые компоненты без логики, такие как кнопки, инпуты, лейблы.
- **Молекулы**: Сборки атомов, более сложные элементы с взаимосвязанными частями.
- **Организмы**: Комбинации молекул и атомов с добавлением логики и стилизации.
- **Шаблоны**: Компоненты, содержащие места для вставки других компонентов (в _слоты_), которые позже могут быть заполнены атомами, молекулами или организмами.

# Структура

- **Организация компонентов**: Рекомендуется разделять компоненты на группы по функциональному назначению (например Mantine) или использовать Atomic Design. Например, группируйте компоненты **по типам**: кнопки, формы, лоадеры или **по логическим группам**, например: кнопки, формы, модальные окна и т.д.
- **Использование index.ts**: Как и в случае с Lib, рекомендуется использовать **index.ts** для создания Public API каждого компонента/группы, чтобы можно было изменять внутреннюю структуру без влияния на потребителей этого компонента.
- **Storybook и Readme**: Добавляйте **Storybook** для визуального представления компонентов и **Readme** для описания их назначения. Это помогает всем участникам команды быстро понять, какие компоненты уже существуют и как их использовать. Кроме того, можно запускать тесты внутри Storybook.

# Тестирование

- **Снапшот-тесты**: Не рекомендуется использовать снапшот-тесты для проверки верстки компонентов. Снапшоты подходят для тестирования поведения кода, но не для интерфейса, так как вызывают каскад падений тестов и сотни тысяч строк изменений.
- **Разделение стилей и логики**: Для каждого компонента создавайте отдельные файлы для стилей, логики и тестов, чтобы облегчить восприятие и поддержку кода.

# Другие Сегменты

Внутри слоя Shared можно создавать дополнительные базовые сегменты, вот некоторые из них.

### Routing

Этот сегмент хранит глобальные маршруты и управляет навигацией, в нем также можно разместить проверки прав доступа. Он обеспечит универсальный доступ для всех слоев, исключая необходимость дублирования кода. **Routing** является важной базовой частью приложения и может использоваться практически во всех слоях приложения.

### Viewer

Еще одним интересным сегментом является **Viewer**, который хранит данные и функции, связанные с текущим пользователем, такие как авторизация, получение информации профиля и проверка прав доступа. Этот сегмент также размещается в **Shared**, чтобы он был доступен всем остальным слоям.
