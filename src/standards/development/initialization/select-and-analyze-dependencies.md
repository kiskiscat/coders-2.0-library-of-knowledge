# Подбираем и анализируем зависимости

На рынке довольно много технологий, некоторые создаются обычными разработчиками, некоторые компаниями.

При выборе технологии стоит учитывать как плюсы, так и риски.

Как вообще понять, каком состоянии open-source технология, если количество скачиваний и звезд не отражает действительности, по ним невозможно понять подходит ли технология именно в ваш проект.

## Введение

Почти любой продукт можно реализовать на чистом JavaScript, используя API браузера или серверного рантайма, но для этого потребуется написать очень много кода и даже изобрести некоторые концепции заново.

Если продукт придется писать в команде, то хорошо бы составить документацию, чтобы другие разработчики могли самостоятельно разобраться, как пользоваться написанным кодом, в каких архитектурных правилах есть исключения, а где ошибок допускать нельзя.

Кроме того, придется покрыть тестами каждый критический компонент, чтобы иметь хоть какие-то гарантии работоспособности и не бояться вносить изменения в существующий код.

Для огромного, по количеству функций, продукта зачастую имеет смысл разделять код на чанки и поставлять пользователю только необходимые на момент запроса, мало кто захочет скачивать 200мб javascript-кода, просто чтобы посмотреть простой dashboard. Чтобы эти части могли общаться друг с другом, придется продумать протокол общения, поставлять одинаковую реализацию протокола, а затем во-время всё обновлять.

### Зачем нужны зависимости

В современном мире, никто не реализует полностью все части продукта с нуля. Компании, а также разработчики-волонтеры публикуют свой код готовых решений под open-source лицензиями, чтобы другие компании и одиночные разработчики могли переиспользовать код.

Самым популярным местом для публичного хранения кода остается [github.com](http://github.com). Разработчики-авторы публикуют репозитории, а разработчики-потребители могут бесплатно выкачивать код, предлагать изменения и улучшения, оставлять вопросы. Код в репозиториях полностью версионируется, позволяя пользоваться не самой последней версией кода, обновляя по необходимости.

В современных web-проектах переиспользовать чужой код настолько же легко, как и добавить одну строку в файл, или выполнить одну команду в эмуляторе терминала. Например: `npm add react`.

### Цели

Использование чужого кода предлагает как существенные преимущества, так и не очевидные риски. С одной стороны, чужой код позволяет освободить время команды, упростить создание сложных интерфейсов, улучшить надежность проекта, уменьшить размер команды и т.д.

А с другой стороны, чужой код требует доверия к автору, трат времени на изучение как им пользоваться, решение проблем конфликта зависимостей, расширение возможностей, проверки лицензирования и т.д.

Здесь рассматриваются критерии оценки зависимостей, методика подбора зависимостей, как работает реестр npm, а также какие лучшие практики можно перенять, чтобы уменьшить боль от пользования зависимостями.

## Как оценивать зависимости

В web-проектах обычно установлено много зависимостей для разных целей, одни помогают проверить валидность кода, другие собрать десятки тысяч файлов в пачку, третьи реализуют алгоритмы, четвертые элементы интерфейса и так далее.

## Типы зависимостей

Обычно зависимости разделяют на типы, по способу их использовать и обновлять.

### production

Зависимости, которые используются непосредственно при реализации логики проекта. Можно увидеть импорты этих зависимостей в файлах в директории src.

Обновлять production зависимости стоит осторожно, потому что они напрямую взаимодействуют с пользователем в браузере или же с его данными на сервере.

Например: react, react-dom, effector, @mantine/core, dayjs, recharts.

### development

В эту категорию обычно попадают все остальные зависимости, которые не присутствуют в импортах проекта, но реализуют всякую инфраструктурную логику: сборку проекта, валидацию, форматирование, проверку типов, запуск тестов, генерацию кода и так далее.

Development зависимости можно обновлять чаще, чем production, потому что эти зависимости обычно взаимодействуют с кодом проекта, а не с данными пользователя.

Например: @types/react, vitest, prettier, eslint, typescript.

### peer

Peer dependency - это способ указать, что один пакет (чаще библиотека) зависит от другого пакета, который должен быть установлен в родительском проекте. Это важно, когда два пакета, которые используются в проекте, должны быть совместимы друг с другом, но не могут зависеть друг от друга напрямую. Этот тип зависимостей используется гораздо реже в web-продуктах, чаще его можно увидеть в библиотеках.

Например, при установке @mantine/dropzone потребуется наличие установленного @mantine/core. Другими словами, @mantine/core прописан как peerDependency внутри пакета @mantine/dropzone. Чтобы использовать dropzone, нужно установить еще и core.

Обновление Peer зависимостей выполняется только ~~по праздникам~~ при масштабном обновлении, например переход на новую версию React. Больше об этом можно почитать в Semantic Versioning.

### transitive

Transitive dependency - это зависимость, которая не указывается напрямую в проекте, но используется зависимостью, которая напрямую указана в проекте.

Например: проект использует библиотеку @mantine/dropzone, значит эта зависимость напрямую указана в проекте. В свою очередь, @mantine/dropzone зависит от библиотеки react-dropzone-esm. Таким образом в проекте будет установлена и библиотека @mantine/dropzone и react-dropzone-esm.

project → @mantine/dropzone → react-dropzone-esm

Таким образом библиотека react-dropzone-esm является транзитивной зависимостью проекта.

Обновлением transitive зависимостей обычно заниматься не требуется. Но в некоторых случаях можно указывать версии транзитивных зависимостей с помощью yarn или pnpm.

## Критерии оценки зависимостей

Когда разработчик сталкивается с необходимостью разработать новую функциональность или улучшить существующую, он встает перед выбором: написать код самостоятельно или использовать уже готовый.

Всегда имеет смысл рассмотреть возможность использовать существующий код. Стоит учитывать, что npm-пакет, как и github-репозиторий может опубликовать абсолютно любой человек, то есть внутри может лежать любой код, в том числе вредоносный. Не имеет значения какими словами автор хвалит свой труд в README, главное, как написан код.

В 2022 году на Github было зарегистрировано 94 млн пользователей, из чего можно прикинуть, что даже если 1% пользователей опубликует хотя бы один репозиторий, будет примерно 940 000 репозиториев. Очевидно, что не все заслуживают внимания, внушительная часть из которых это тестовые или pet-проекты.

Как выбрать какую open source зависимость стоит использовать в проекте? Для начала стоит собрать список кандидатов, а затем коротко оценить их по нескольким критериям:

### 1. Популярность

Количество звёзд и форков на Github позволяет оценить сколько внимания к себе привлек проект. Чем больше людей, тем вероятнее, что самые популярные проблемы уже решены и их можно найти в issues.

Количество загрузок в npm указывает на количество установок пакета как зависимости. Здесь подчеркиваю, только указывает, ибо не редко компании используют прокси, вроде Verdaccio и Nexus, а значит часть загрузок просто не видна. С другой стороны, проекты, вроде Snyk и аналоги, мониторят выход новых версий пакетов и скачивают их, для сбора статистики/аналитики/etc, что завышает видимое число загрузок.

### 2. Активность

Github предоставляет несколько страниц аналитики по open source проектам. Предлагаю открыть Insights страницу и посмотреть все вкладки. Стоит обращать внимание на графики коммитов в репозитории, они расскажут о частоте обновления проекта, а также о главных разработчиках. Не стоит удивляться, если на крупных и важных проектах их будет 1-2.

Кроме того, можно сравнить количество открытых/закрытых issues, посмотреть на время ответа, а также причины закрытия, сколько issue висит без ответа или решения. Аналогичный анализ можно сделать с Pull Requests. Не нужно анализировать все, стоит выбрать хотя бы 10 интересных из самых последних.

### 3. Стабильность

Проверьте наличие файла [CHANGELOG.md](http://CHANGELOG.md), [CONTRIBUTING.md](http://CONTRIBUTING.md), эти файлы подскажут как часто проект обновляется, по каким правилам, а также как самостоятельно предложить изменения.

На главной странице проекта в Github можно найти секцию Releases, оценить насколько часто выпускаются новые версии, какой системе версионирования следуют и насколько подробно описаны.

В идеале, все npm-пакеты должны следовать семантическому версионированию (semver), когда версия указывается в виде трех чисел 1.2.3, каждое число обновляется по правилам. Эти правила используются пакетными менеджерами при установке зависимостей. Любые, не semver, схемы версионирования могут вести себя неожиданно, так что об этом точно нужно знать.

Например, typescript не следует semver, из чего следует, что его версию стоит фиксировать намертво и не обновлять без запуска всех возможных тестов в проекте.

### 4. Размер и Производительность

Самый простой и наивный способ оценить производительность - это размер финального бандла npm-пакета. Базовый размер пакета указан в npm, но это не самые честные цифры, потому что в проектах обычно используются бандлеры, которые отбрасывают неиспользуемый код и сжимают оставшийся. К тому же, браузеры имеют поддержку разных видов сжатия (gzip, brotli, deflate, etc).

Для более реальной оценки размера кода зависимости стоит использовать Bundlejs и Bundlephobia. Каждый сервис может показывать разные результаты, так как использует разные способы оценки, поэтому не стоит полагаться только на один способ.

Сейчас библиотеки зачастую собираются не в виде единого бандла, а поставляются в виде отдельных файлов, иногда даже в виде ts-исходников, что может разительно повлиять на размер кода библиотеки действительно используемого в вашем проекте.

Помимо размера js в библиотеке, есть еще и производительность написанного кода. Хорошей практикой может быть наличие бенчмарков, то есть инфраструктуры для оценки скорости работы кода. По бенчмаркингу можно написать целую книгу, но главное, что стоит учитывать: авторы бенчмарков для своих проектов далеко не всегда могут честно оценить свой труд, стоит смотреть на бенчмарки от разработчиков не связанных с исследуемым проектом.

К тому же, написать качественный сравнительный бенчмарк довольно сложно, ведь придется сделать полную копию логики на разных библиотеках, в которых могут использоваться очень разные подходы, влияющие на итоговый результат. Причем результат, обычно записан в виде “попугаев”, то есть миллионах операций в секунду, тогда как реальные проекты могут никогда не вызывать код так часто.

В общем, наличие бенчмарков хорошо, но не гарантия высокой производительности. Стоит делать собственные замеры в настоящем проекте и сравнивать фактические результаты.

### 5. Безопасность

Github и NPM имеет несколько встроенных инструментов проверки зависимостей на уязвимости. Стоит удостовериться, что авторы проекта регулярно закрывают известные уязвимости и принимают исправления от внешних разработчиков.

Можно установить зависимость в безопасном окружении и запустить `npm audit`, а также проверить настроены ли системы автоматического обновления зависимостей, например dependabot в Github.

Помимо всех этих проверок, стоит поискать файл [SECURITY.md](http://SECURITY.md), а также упоминание сколько прошлых версий всё еще поддерживаются. Хороший пример - Node.js Release Schedule, где четко указано, сколько времени будут выпускаться обновления безопасности для каждой мажорной версии.

### 6. Документация

Можно выделить два типа документации, наличие которых стоит проверить.

1. **Постраничная**

   Самый распространенный тип документации сегодня. Все необходимые концепции обозначены в виде страниц на веб-сайте. Страницы пишутся в отдельных от кода файлах, но зачастую в том же репозитории.

   Главная сложность - синхронизировать документацию, при изменении кода. Чек-лист при создании Pull Request вполне может улучшить ситуацию. Стоит просмотреть какие Pull Requests висят открытыми, смержены и отвергнуты.

2. **Автогенерируемая**

   Эта документация может быть создана автоматически из комментариев к коду в формате JSDoc.

   А с помощью проектов вроде doc-vitest, можно во время запуска тестов запустить код из блоков `@example` в JSDoc, гарантировав, таким образом, работоспособность примеров в документации.

   Покликав документацию можно понять насколько хорошо описана секция API. Но, не все проекты могут позволить себе такой вид документации.

Наличие чего-то большего, чем [README.md](http://README.md) на 5000 строк, это уже плюс к оценке проекта как завивимости.

### 7. Совместимость

В 2021 году sindresorhus начал крестовый поход против CommonJS модулей. А до тех пор существовали еще AMD модули. Поэтому важно уточнить вопрос поддержки модульной системы, которую использует ваш проект. Если Вы начинаете проект пока читаете этот текст, то стоит рассмотреть ES Modules.

Кроме этого, в начале проекта можно использовать самую последнюю версию Node.js (v22.6). К моменту как проект будет готов к релизу, версия будет еще стабильнее, или уже уйдет в LTS. Но не все продукты могут позволить себе такой новаторский подход. В таком случае стоит брать самую старшую LTS версию, она позже уйдет из поддержки. Для bun, deno и других рантаймов стоит смотреть их Release Schedule.

Помимо версии рантайма стоит проверить требования peer dependency. В уже существующих проектах не всегда имеются последние версии зависимостей, даже в open source.

### 8. Лицензия

Существует множество видов open source лицензий, которые можно вкратце разбить по группам

- **Копилефтные лицензии:** Эти лицензии требуют, чтобы производные проекты также распространялись под той же лицензией.

  Примеры: GNU GPL, LGPL, GNU AGPL.

- **Пермиссивные лицензии:** Эти же лицензии предоставляют больше свободы для использования, модификации и распространения проектов.

  Примеры: MIT, Apache 2.0, BSD (2-Clause, 3-Clause).

- **Прочие лицензии:** Некоторые организации создают лицензии под свои требования. Например Mozilla Public License - это компромисс между копилефтом и разрешительными лицензиями, позволяющая смешивать открытый и закрытый код.

Выбор лицензии зависит от целей разработчика и желаемого уровня контроля над использованием кода. Копилефтные лицензии обеспечивают защиту свободного программного обеспечения, в то время как разрешительные лицензии предоставляют большую гибкость для коммерческого использования. Следовательно, необходимо тщательно рассматривать, какие действия допустимы с кодом, даже если он относится к категории open source.

### 9. Типизация

Не все npm-пакеты, имеют встроенную поддержку typescript, в отличие от deno/jsr. В этом случае, сторонние разработчики публикуют пакет только с типами, подходящими к оригинальному пакету.

Например, [npmjs.com/cookie](http://npmjs.com/cookie) не имеет встроенного описания типов, поэтому приходится в довесок ставить пакет [npmjs.com/@types/cookie](http://npmjs.com/@types/cookie).

А раз, пакет с типами обновляется сторонними разработчиками, то будет возникать ситуация, когда типы расходятся с реализацией. Приходится выяснять подходящую версию пакета с типами под оригинальный пакет и крайне аккуратно обновлять.

Современные проекты обычно имеют автоматическую генерацию типов из исходного кода. Хоть это и не главный показатель качества, но наличие его всегда приятно.

### 10. Качество

Стоит почитать исходники пакета, чтобы оценить насколько понятно происходящее внутри. Авторы с достаточным временем и финансированием комментируют код, поясняя как именно работают внутренние механизмы, если они там имеются.

Помимо комментариев стоит оценить качество и количество тестов, что они проверяют, какой процент покрытия, есть ли тесты типов, может даже интеграционные имеются.

Есть ли настроенные линтеры, форматтеры и конфиги для IDE. Все это помогает держать кодовую базу в едином стиле и избегать распространенных ошибок.

### 11. Экосистема

Если проект не молодой, но активно развивающийся, то стоит поискать гайды и плагины, для интеграции с инструментами в вашем техническом стеке.

Например, проект tiptap имеет интеграции со многими фреймворками React, Vue, Svelte и т.д. Кроме этого у него богатая коллекция плагинов-расширений, которую стоит изучить.

В некоторых случаях, проект может предлагать плагины для Babel или SWC, для преобразования кода во время сборки. Почти все современные бандлеры используют преобразования кода в своей работе. Имеет смысл изучить, не потребуется ли менять выбранный компилятор или же запускать оба по очереди, что замедляет скорость сборки.

### 12. Сообщество

Обязательно изучить количество контрибуторов и частоту коммитов. Этот показатель важен для проектов с большим количеством кода, то есть мест где могут возникать баги. Никто не отменял Bus Factor, поэтому стоит поискать документы описывающее внутреннее устройство, гайды как вносить изменения и прочие. На [opensource.guide](http://opensource.guide) можно найти подробные рекомендации как вести open source проект.

Так как у open source проектов обычно 1-2 основных контрибьютора, стоит выяснить, как можно с ними контактировать. Например, есть Discord/Telegram чат, где можно пообщаться с другими пользователями проекта и/или контрибьютерами.

Стоит поискать статьи, на [dev.to](http://dev.to), [medium.com](http://medium.com), habr и прочих, об этом инструменте, чтобы узнать разные точки зрения, а также взглянуть на комментарии. Отсутствие статей разбирающих сложные аспекты работы исследуемого проекта может быть красным флагом в совокупности со скудной документацией.

Кроме всего этого стоит поискать в README, на сайте проекта, или же в блоге наличие информации о финансовой поддержке проекта. Наличие пожертвований Github Sponsors, OpenCollective, IssueHunt - это плюс. А вот существенные и регулярные вложения от компаний-потребителей, могут быть минусом, так как в этом случае фокус авторов проекта может быть смещен с разработчиков-потребителей на эти компании.

### 13. Зрелость

Первым шагом нужно изучить историю версий, либо на NPM, либо на Github Releases. Если авторы добавляют метки релизов, кроме latest, значит, что пакет проходит этап предварительного тестирования, перед выходом нового релиза.

Важно, какие изменения представлены в релизах и как часто. Если пакет часто ломает обратную совместимость, то будет сложно регулярно обновляться и проект может зависнуть на старых версиях, не имея возможности обновиться, даже ради исправлений безопасности.

В документации стоит поискать гайды по миграции на более свежие версии. Без таких гайдов, будет довольно сложно обновляться, особенно если сообщество небольшое.

### 14. Зависимости

При оценке open source проекта в качестве зависимости для своего проекта, важно обратить внимание на его собственные зависимости.

Чем меньше зависимостей у проекта, тем меньше риск возникновения конфликтов и проблем с совместимостью. Пакеты с большим количеством зависимостей может быть сложнее обслуживать, что повышает вероятность появления уязвимостей и конфликтов версий.

Наличие peer и optional зависимостей показывает что потребуется установить для использования пакета. Если версия peer зависимости конфликтует с версией в вашем проекте, то возможно придется принимать дополнительные шаги по исправлению.

Стоит проверить частоту обновлений зависимостей, настроен ли dependabot, для автоматизации процесса. Еще один флаг, что проект не заброшен.

Потенциально нужно проверить каждую зависимость пакета по всем описанным здесь критериям. С помощью license-checker или license-report можно автоматизировать проверку совместимости лицензий. Сервисы вроде [socket.dev](http://socket.dev) и [snyk.io](http://snyk.io) могут ускорить проверку зависимостей.

Используя список кандидатов оцененный по всем этим критериям, можно рационально оценить каждый вариант и принять решение какую зависимость использовать, опираясь на факты.

## Технологии зависимостей

### Что такое NPM

Устанавливать зависимости из Github вполне можно, но не так удобно, как в отдельном надежном хранилище. Ведь в Github разработчик может удалить свой репозиторий, передвинуть метку версии на другой коммит или выполнить `git push --force`.

Node Package Manager (NPM) состоит из нескольких составляющих, основной целью которых является управление зависимостями в JavaScript проектах. Изначально NPM существовал именно для Node.js, но его формат установки модулей поддерживается и другими рантаймами.

NPM состоит из a) приложения командной строки CLI, b) реестра пакетов [registry.npmjs.com](http://registry.npmjs.com), c) веб-сайта [npmjs.com](http://npmjs.com).

Сейчас есть несколько альтернатив npm: yarn, pnpm. Более того, в Node.js встроен инструмент управления менеджерами пакетов Corepack, который упрощает работу с альтернативными менеджерами пакетов как локально так и в CI/CD скриптах.

Сейчас, NPM является неотъемлемой частью экосистемы JavaScript проектов и активно используется для управления npm-пакетами в проекте, а также для публикации новых версий npm-пакетов в реестр.

NPM CLI состоит из команды `npm` с десятками подкомманд для разных целей: добавить зависимость, установить всё из package.json, показать уязвимые версии зависимостей в проекте. Можно сравнить набор команд по очереди вызвав `npm help`, `yarn help`, `pnpm help`.

При установке зависимостей, NPM CLI найдет `package.json` файл или создаст его, затем найдет список необходимых зависимостей и промежутки версий для них, скачает архивы, распакует в директорию `node_modules`. Отличия пакетных менеджеров в основном в скорости скачивания, методике установки в node_modules, а также устройстве lock-файла.

Для публикации в NPM реестр необходимо зарегистрироваться и выписать access token. Любой менеджер пакетов позволяет получать доступ к вашему аккаунту на [npmjs.com](http://npmjs.com). К тому же, можно запустить собственный реестр пакетов на Nexus или Verdaccio.

### package.json

Это главное описание вашего проекта, его зависимостей, метаданных о версии, авторстве, ссылках на issues и readme, доступных скриптах.

Менеджеры пакетов работают с этим файлом очень похожим образом, но с рядом отличий. О чем можно почитать в документации выбранного менеджера пакетов.

Стоит обратить внимание на поле `type`, которое описывает тип модулей в этом пакете. Если `type: module`, значит, что этот модуль написан в формате ES Modules и импортировать его удобнее всего именно из проекта на ES Modules.

Некоторые проекты генерируют package.json кодом во время сборки новой версии пакета. Так можно убрать лишние поля вроде devDependencies, scripts, config, которые никак не используются при установке пакета как зависимость.

### lock-file

Современные пакетные менеджеры создают еще один файл рядом с package.json: `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`.

В этих файлах записываются точные версии для всего дерева зависимостей. При следующей установке зависимостей, конкретные версии изымаются именно из lock-файлов, если конечно диапазоны версии указанные в package.json подходящие.

Именно lock-файлы гарантируют воспроизводимость окружения и всего дерева зависимостей на разных машинах, исключая ситуацию “у меня не работает, а на твоей машине всё работает”. Четко указанные версии зависимостей помогают избегать неожиданного изменения поведения, из-за обновления глубоких транзитивных зависимостей.

В lock-файлах записываются контрольные суммы (checksums) архивов установленных пакетов, что позволяет убедиться в их неизменности и целостности. Если кто-то на любом уровне подменил содержимое пакета, контрольная сумма не совпадет и вывалится ошибка.

Есть два подхода к lock-файлам в репозиториях.

1. **Коммитить.** В случае, если проект это не npm-пакет под публикацию в реестр, а некий `"private": true`, для сборки веб-приложения, то всегда стоит коммитить ваш lock-файл. В случае изменений в списке зависимостей это будет видно в git diff.
2. **Не коммитить.** Если проект это npm-пакет, здесь стоит сфокусироваться на поддержке широкого спектра версий зависимостей. У пользователей пакета могут быть разные пакетные менеджеры, а генерировать под каждый менеджер пакетов свой lock-файл и поставлять его вместе с npm-пакетом выглядит как бесполезной затеей.

Если коммитить lock-файл в проект, то могут возникнуть сложности с использованием. Например, конфликты при мержах Pull Requests. В случае pnpm, можно выкачать конфликт на локальную машину и выполнить `pnpm i`, пакетный менеджер сам найдет конфликты и исправит их, останется только закоммитить и запушить изменения.

Стоит зафорсить использование одного пакетного менеджера на всю команду. Чтобы не появлялось несколько разных lock-файлов, и версии в lock-файлах не рассинхронизировались с package.json. Сделать это можно через corepack и `packageManager` поле в package.json:

```bash
corepack use pnpm@latest
# pnpm@9.7.1+sha256.46f1bbc8f8020aa9869568c387198f1a813f21fb44c82f400e7d1dbde6c70b40
```

Эта команда создаст поле `packageManager` и запишет в него конкретную версию менеджера пакетов и его название. При попытке использовать `npm` или `yarn` будет отображена ошибка: _Usage Error: This project is configured to use pnpm_. Таким образом можно избежать ошибок сделанных по привычке к другому пакетному менеджеру.

В любом случае, стоит развивать культуру чистого кода и проекта в команде и устранять ситуации “у меня не работает с pnpm, поэтому я установил yarn”. **Ошибки имеют отвратительное свойство накапливаться** и в самый ответственный момент начинает ломаться все разом.

В отличие от остальных пакетных менеджеров, pnpm устанавливает зависимости особым образом, увеличивая безопасность и надежность приложения.

Во первых, pnpm устанавливает зависимости в глобальный storage, откуда с помощью символьных ссылок линкуются зависимости в проект. Этот подход позволяет переиспользовать скачанные зависимости для разных проектов, уменьшая занимаемое дисковое пространство.

Во вторых, pnpm не позволяет импортировать в коде транзитивные зависимости, явно не указанные в package.json.

Не редки случаи, когда в проекте установлена зависимость A, которая зависит от B. Если в коде импортировать B с npm и yarn, то все будет работать, но так как версия не зафиксирована в package.json, в любой момент зависимость A может обновить версии своих зависимостей, в том числе удалить зависимость B, например мигрировать на B-esm. Теперь после простейшего обновления, код в проекте использующем A, совершенно непредсказуемо ломается.

`pnpm` переносит транзитивные зависимости в отдельную директорию, не позволяя импортировать их из исходного кода проекта. Форсируя практику явного указания используемых зависимостей в package.json.

## Как работает NPM-реестр

Реестр представляет собой документ-ориентированную базу CouchDB, в которую зарегистрированные пользователи могут загружать пакеты под определенными версиями. До недавних пор, можно было и удалять любые версии пакетов, которыми владеешь, но случилась история с `left-pad`, когда владелец удалил все свои пакеты, следом за этим сборка кучи проектов легла, так как left-pad был транзитивной зависимостью с миллионами скачиваний в день.

Теперь, реестр представляет собой неизменяемое хранилище пакетов. Пакеты может удалять только Microsoft, владеющая [npmjs.com](http://npmjs.com). В остальном, можно полагаться на наличие пакета, если он был опубликован.

## Полезные практики

### Семантическое версионирование

Версия пакета может изменяться по множеству разных причин, и в большинстве случаев обычный инкремент версии не подходит.

При публикации пакета автор определяет набор возможностей библиотеки через её API, то есть через список функций/интерфейсов/классов доступных пользователю этой библиотеки. В package.json можно указывать конкретную полную версию пакета, а можно указать некий промежуток, который используется по умолчанию. NPM будет устанавливать последнюю доступную версию в пределах промежутка.

Учитывая эту особенность установки пакетов определенных версий, авторы пакетов могут следовать определенным стандартам изменения версий пакета. Самый распространенный это semver: `MAJOR.MINOR.PATCH-PRERELEASE`. Например: `1.2.3`, `0.10.5`, `12.22.110`, `3.0.0-dev1` и так далее.

Когда в проекте накопилось достаточно изменений, которые несовместимы с предыдущей версией, увеличивают MAJOR, все остальные компоненты версии сбрасываются до нулей.

Если же изменения совместимы с предыдущей версией, но добавляют новую функциональность, то увеличивается MINOR версия, а PATCH и PRERELEASE сбрасываются до нулей.

Если же были внесены только исправления багов, улучшения производительности или что-то еще не вносящее новых функций и не ломающе совместимость, то увеличивается PATCH компонент версии.

PRERELEASE используется для еще более детального дробления версии. Можно указывать вплоть до полного набора версий: `1.0.0-alpha.1`, `1.2.3-3.2.1`. К тому же можно добавить METADATA в конец версии, которая никак не влияет на отношение версий, только добавляет информацию. Пример: `1.0.0+20130313144700`.

Чаще всего версии записываются в package.json с символом `^`, например:

```json
{
  // .. extra fields
  "dependencies": {
    "react": "^16.8.0"
  }
}
```

Такая запись указывает менеджеру пакетов установить любую версию react, которая подходит под диапазон версий от 16.8.0 до 17.0.0 НЕ включительно. То есть может быть установлена версия 16.8.0, или 16.8.1, или 16.14.2. Диапазон `^16.8.0` еще можно записать так `>16.8.0 || <17.0.0` или даже `16.x`, если подходят все версии 16 мажора.

Менеджер пакетов сам определяет как именно устанавливать, например исходя из требований транзитивных зависимостей. То, что указано в package.json это не фактически установленные версии, это лишь некое требование, какие версии проекту подходят.

Реальную версию можно увидеть с помощью команд:

```bash
npm ls PACKAGE_NAME --depth=0
pnpm why PACKAGE_NAME
yarn why PACKAGE_NAME
```

При переустановке зависимостей, версии могут быть определены заново и установлены другие версии в проект, что может приводить к проблемам. Например, в package.json указан `react: ^16.8.2`, была установлена последняя `16.14.5`, но во время следующей установки выяснилось, что последняя версия теперь `16.15.0` и будет выкачана именно она.

В реальности, даже минорные и патч версии могут сломать код или же поведение, и хорошо бы немного готовиться к обновлению зависимостей. Еще лучше, если бы набор зависимостей был полностью идентичен при каждой установке, на каждом устройстве, в том числе на CI/CD.

## Заключение

В современной разработке выбор подходящих задаче зависимостей определяют скорость разработки и даже размер команды. Мы рассмотрели критерии оценки зависимостей, от популярности и активности в репозитории до безопасности и производительности. Важно помнить, что каждый проект уникален и одного правильного решения нет.

### Постоянный мониторинг и обновление зависимостей

Управление зависимостями - это не разовая акция, а непрерывный процесс. Регулярный мониторинг, проверка и обновление зависимостей критически важны для поддержания проекта в чистом и здоровом состоянии. Любые предупреждения и ошибки при установке стоит устранить как можно скорее.

Стоит завести регулярную задачу/напоминание о проверке зависимостей. Некоторые обновления зависимостей требуют изменения кода в проекте, поэтому к их обновлению стоит готовиться заранее.

А вот откладывание обновления накапливается как снежный ком, через какое-то время обновления просить будут все зависимости, а обновление всех сразу ломает проект, потому что приходится обновляться через несколько мажорных версий.

### Подведение итогов

Чтобы держать проект в здоровом состоянии можно использовать готовые практики:

1. **Автоматизация проверок.** Настроить dependabot/renovate/snyk для автоматической проверки обновления зависимостей и фиксов уязвимостей. Обычно можно указать произвольную регулярность.
2. **Регулярный аудит.** С помощью `npm audit` или оповещений в email-рассылках узнавать об уязвимостях и во время их исправлять.
3. **Постепенное обновление.** Обновлять зависимости небольшими группами или вообще по одиночке. После каждого обновления коммититься и проверять работоспособность проекта. _Лучше узнать на этом этапе, если что-то сломалось, чем после обновления всего провести регрессионное тестирование, а потом с_ `git bisect` ползать по всем коммитам в поисках виновника.
4. **Ведение changelog.** Даже для обычных проектов стоит вести минимальный changelog/releases. Так появляется хоть какая-то возможность разобраться, что было сделано в проекте. Но можно настроить автоматическую генерацию changelog из названий Pull Requests.
5. **Баланс.** При выборе между несколькими кандидатами в зависимости вашего проекта, проведите тщательный анализ и ищите баланс между функциональностью и потенциальными рисками использования.
6. **Культура в команде.** Развивайте культуру чистого проекта в команде. Это относится к именованию коммитов, оформлению Pull Requests, запуску тестов, обновлению документации и так далее. Всё это поможет вам нанимать других людей и разбираться самостоятельно, когда пройдет достаточно времени.

## Ссылки и статьи

- [effector on NPM](https://libraries.io/npm/effector)
- [effector v23.2.2 ❘ Bundlephobia](https://bundlephobia.com/package/effector@23.2.2)
- [GitHub Star History](https://star-history.com/#effector/effector&Date)
- [Contributors to effector/effector](https://github.com/effector/effector/graphs/contributors)
- [npm Registry](https://help.sonatype.com/en/npm-registry.html)
- [A lightweight Node.js private proxy registry | Verdaccio](https://verdaccio.org/)
- [View @mantine/core on Snyk Open Source Advisor](https://snyk.io/advisor/npm-package/@mantine/core)
- [Pulse · mantinedev/mantine](https://github.com/mantinedev/mantine/pulse)
- [Semantic Versioning 2.0.0](https://semver.org/)
- [About semantic versioning | npm Docs](https://docs.npmjs.com/about-semantic-versioning)
- [https://github.com/microsoft/TypeScript/issues/39269](https://github.com/microsoft/TypeScript/issues/39269)
- [Why TypeScript Doesn't Follow Strict Semantic Versioning | Learning TypeScript](https://www.learningtypescript.com/articles/why-typescript-doesnt-follow-strict-semantic-versioning)
- [Bundlephobia | Size of npm dependencies](https://bundlephobia.com/)
- [bundlejs - Online bundler + npm package bundle size checker](https://bundlejs.com/)
- [Keep all your packages up to date with Dependabot](https://github.blog/news-insights/product-news/keep-all-your-packages-up-to-date-with-dependabot/)
- [Auditing package dependencies for security vulnerabilities | npm Docs](https://docs.npmjs.com/auditing-package-dependencies-for-security-vulnerabilities)
- [Node.js - Node.js Releases](https://nodejs.org/en/about/previous-releases)
- [How To: update documentation for the next release](https://github.com/gitextensions/gitextensions/wiki/How-To:-update-documentation-for-the-next-release)
- [https://github.com/ssssota/doc-vitest](https://github.com/ssssota/doc-vitest)
- [https://github.com/sindresorhus/got/releases/tag/v12.0.0](https://github.com/sindresorhus/got/releases/tag/v12.0.0)
- [Pure ESM package](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c)
- [Release Schedule](https://docs.deno.com/runtime/manual/references/contributing/release_schedule/#release-schedule)
- [Install the Editor | Tiptap Editor Docs](https://tiptap.dev/docs/editor/getting-started/install)
- [Open Source Guides](https://opensource.guide/)
- [npm: license-report](https://www.npmjs.com/package/license-report)
- [npm: license-checker](https://www.npmjs.com/package/license-checker)
- [effector - npm Package Security Analysis - Socket](https://socket.dev/npm/package/effector)
- [View effector on Snyk Open Source Advisor](https://snyk.io/advisor/npm-package/effector)
- [effector vs mobx: Detailed NPM Packages Comparison | Performance, Security & Trends](https://moiva.io/?npm=effector+mobx)
- [Home page | Yarn](https://yarnpkg.com/)
- [Fast, disk space efficient package manager | pnpm](https://pnpm.io/)
- [Corepack | Node.js v22.6.0 Documentation](https://nodejs.org/api/corepack.html)
- [Creating a package.json file | npm Docs](https://docs.npmjs.com/creating-a-package-json-file)
- [package.json | npm Docs](https://docs.npmjs.com/cli/v10/configuring-npm/package-json)
- [package.json | pnpm](https://pnpm.io/package_json)
- [https://github.com/mobxjs/mobx/blob/62d994d32d89500cf9cf10e0ee76e6fb50a44f41/packages/mobx/package.json](https://github.com/mobxjs/mobx/blob/62d994d32d89500cf9cf10e0ee76e6fb50a44f41/packages/mobx/package.json)
- [How one programmer broke the internet by deleting a tiny piece of code](https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code)
- [Semantic Versioning 2.0.0](https://semver.org/)
- [npm version cheatsheet](https://gist.github.com/jonlabelle/706b28d50ba75bf81d40782aa3c84b3e)
