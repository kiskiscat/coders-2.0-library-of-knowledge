# Составляющие приложения

## Введение

В современном мире веб-разработки понимание общих принципов работы веб-приложений становится не просто преимуществом, а необходимостью. Независимо от используемых технологий и фреймворков, конечный результат для пользователя зачастую неотличим: пользователь смотрит в экран, взаимодействует с интерфейсом и ожидает определенного результата.

Мы рассмотрим, какие есть основные сущности, как они взаимодействуют друг с другом и почему их понимание критически важно для создания надежных и эффективных приложений. Понимание фундаментальных принципов позволит вам создавать более устойчивые, масштабируемые и удобные для пользователя приложения.

## Приложения с точки зрения пользователей

Обычно, пользователи взаимодействуют с вебом, не задумываясь о технологиях, которые стоят за каждым приложением или сайтом. Независимо от того, используется ли React, Angular, Vue или чистый JavaScript, конечный результат для пользователя зачастую неотличим. Пользователи хотят решить свои задачи, а не запоминать как пользоваться очередным сайтом.

Важно подчеркнуть наличие границы между техническими деталями и опытом пользователя. Последний не должен ощущать на себе сложности реализации или выбор технического стека. Его интересует лишь то, насколько удобно и эффективно он может решить свои задачи с помощью вашего приложения.

### Восприятие веб-приложений пользователем

Пользовательский опыт формируется на основе взаимодействия с множеством различных приложений. Люди привыкают к определенным паттернам и ожидают увидеть знакомые элементы в новых приложениях. Если же интерфейс сильно отклоняется от общепринятых стандартов, пользователям может быть сложно с ним взаимодействовать, а вам придется составлять обучающие гайды и расставлять подсказки в интерфейсе (что само по себе не является плохой практикой).

Например, в стремлении выделиться, некоторые команды создают слишком необычный дизайн интерфейса, что приводит к тому, что пользователи испытывают сложности при попытках выполнить даже простые действия, например отправка форм или проверка статуса.

Мы живем в мире, где уникальный дизайн стал чем-то вроде визитной карточки, поэтому не стоит хейтить дизайнеров раньше времени. Есть смысл учитывать дизайн как одну из важных особенностей разработки приложений для конечных пользователей.

Настойчиво рекомендую исключить из приложения все особенности вашего технического стека, а сосредоточиться на типичных поведенческих паттернах.

### Разница между веб-сайтами и веб-приложениями

Разница между веб-сайтами и веб-приложениями, с точки зрения пользователей, становится все более размытой с развитием фреймворков (Astro, Remix, etc). Веб-приложения предоставляют возможность работать с данными непосредственно в браузере, не отправляя кучу информации на сервер при каждом клике. Этот подход улучшает производительность на устройстве пользователя и позволяет создавать функциональность, доступную даже в офлайне. _Другой разговор об уместности этих оптимизаций и возможностей_.

Хорошим маркером для определения веб-приложения может служить потенциальная возможность поддерживать работу в офлайн-режиме. Такие приложения, как Gmail, Trello или Linear, позволяют пользователям выполнять целый ряд действий без постоянного подключения к интернету, синхронизируя данные с сервером при восстановлении соединения, то есть эти приложения могут выполнять часть своей работы на устройстве пользователя, эту работу можно назвать бизнес-логикой на клиенте.

### Независимость от технологий под капотом

Пользователю не нужно знать о технологиях, используемых под капотом вашего приложения, для комфортного использования, его интересует только то, насколько удобно и эффективно он может решать свои задачи. Поэтому важно сосредоточиться на прозрачности и удобстве интерфейса, чтобы сделать использование приложения комфортным.

Однако, может возникнуть вопрос, как можно обобщить все эти разные виды приложений, всех ведь под одну гребенку не сгрести. В одном случае, у нас realtime обновление панелей управления, в другом социальная сеть, в третьем игра в Telegram, и так далее. Так вот, все приложения используют 3 очень простых концепции, а фреймворки повышают уровень абстракции добавляя новые слои.

### События всему голова

События управляют всем происходящим в приложении. Это не только стандартные события DOM или пользовательские события, которые Вы можете знать благодаря `.addEventListener` и `.dispatchEvent`. В более общем смысле, событие - это оповещение о чём-то случившемся в вашем приложении.

События являются важным звеном в реактивных системах, позволяя приложению реагировать на различные изменения и взаимодействия.

### Виды событий

1. **Пользовательские действия**: клики по кнопкам, ввод текста, перемещение мыши, жесты на сенсорных устройствах.
2. **Браузерные API**: загрузка страницы, изменение размеров окна, скроллинг, события медиа-запросов.
3. **Системные события**: подключение новых устройств, подключение к сети, и другие уведомления операционной системы.

Еще несколько примеров:

- **Клик по кнопке**: Пользователь нажимает на кнопку, срабатывает событие, на которое приложение должно отреагировать.
- **Ввод текста**: При вводе текста в поле формы, приложение может проверять корректность данных в реальном времени, реагируя на событие ввода и запуская событие валидации.
- **Потеря соединения**: Если соединение с интернетом пропадает, приложение может перейти в офлайн-режим и отложить запрос данных.
- **Получение данных с сервера**: После успешного запроса на сервер, приложение может обновить интерфейс, отражая изменения в данных.

### Важность событий в приложении

События являются основой взаимодействия между пользователем и приложением. В том или ином виде события присутствуют даже в фреймворках построенных на классах, стоит воспринимать события скорее как концепцию, а не инстанс класса или реактивный примитив.

Пользователь может взаимодействовать с приложением только через события. Кроме этого, разработчикам могут понадобиться дополнительные примитивы, чтобы очертить бизнес-задачи и внутреннюю логику приложения, в роли которых тоже выступают события.

## Сайд-эффекты и чистые функции

Сайд-эффекты - это изменения, влияющие на окружение за пределами определения функции. Они возникают, когда функция изменяет состояние за пределами своего скоупа, то есть взаимодействует с “внешним миром”.

```ts
// Состояние определено за пределами функции
let externalState = 0;

export function fnWithSideEffect() {
  // функция меняет внешнее состояние
  externalState += 1;
  return externalState;
}
```

_На самом деле, сайд-эффектом будет даже простое чтение внешнего состояния, но об этом позже._

Типичные примеры:

- **Изменение DOM**: манипуляции с элементами на странице.
- **Сетевые запросы**: отправка HTTP-запросов для получения или отправки данных.
- **Работа с хранилищами**: запись или чтение данных из localStorage, sessionStorage, cookies, IndexedDB и так далее.
- **Логирование**: вывод сообщений в консоль или запись логов в хранилище.
- **Нестабильные источники данных**: получение текущей даты или случайных чисел.

### Проблемы с сайд-эффектами

Сайд-эффекты могут порождать неожиданные результаты, вызывать сложности в тестировании и ломать код в неожиданных местах.

Сложно предугадать результат функции, если она зависит от внешних факторов, например, запрос к серверу может оборваться из-за отсутствия интернета, что может сломать дальнейший код, который не ожидает исключительной ситуации.

Тесты могут требовать сложной настройки окружения или использования моков, так как может возникнуть необходимость в изменении реализации функции только ради тестов.

В местах взаимодействия функций с внешним миром могут возникать так называемые “плавающие баги”, которые зависят от некоторого состояния на которого повлиять невозможно, например наличие стабильного интернет-соединения.

Неконтролируемые сайд-эффекты могут приводить к утечкам памяти или избыточному количеству операций. Такое может возникнуть, если сайд-эффекты спрятаны глубоко за другими вызовами функций, а вызывающая сторона не подозревает о потенциальных проблемах производительности.

Какое бы количество проблем и сложностей не вызывали сайд-эффекты, полностью отказаться от них не выйдет - иначе не получится показать результат операций пользователю, ведь даже запись в БД это сайд-эффект.

### Антипод сайд-эффектов

Чистые функции являются по сути полной противоположностью сайд-эффектам, они не модифицируют окружение, полностью предсказуемы, что позволяет с легкостью их тестировать.

В случае с JavaScript можно выделить несколько характеристик, по которым можно узнать чистую функцию:

- **Детерминированы**: всегда возвращает один и тот же результат при одинаковых аргументах.
- **Не имеют сайд-эффектов**: не читают и не изменяют внешнее состояние, вызывают только чистые функции.
- **Иммутабельны:** не модифицируют переданные аргументы, а возвращают новое состояние.

Есть эмпирическое правило, которое с одной стороны поможет лучше понять чистые функции, а с другой может немного запутать, но мы попробуем разобраться:

> 💡 Функция является чистой, если снаружи невозможно заметить наличие состояния.

Например, запись логов, обращение на сервер, чтение внешнего состояния можно заметить снаружи от функции, просто вызывая функцию и сравнивая с другими вызовами. Все эти “ухищрения” при описании чистых функций дают преимущества, которых нет у функций с сайд-эффектами:

- **Композиция:** функции можно легко вкладывать друг в друга, не добавляя сложности вроде try/catch, копирования аргументов перед передачей в функцию или изучения исходников функции перед использованием.
- **Переиспользование:** чистые функции по определению отвязаны от своего окружения за счет чего их легко использовать в другом контексте, что приводит к редкому изменению реализации, ведь гораздо легче написать новую функцию поверх, чем модифицировать существующую.
- **Тестирование** чистых функций превращается в простой набор пар: вход-выход, или аргументы-результат вызова, никаких моков глобальных объектов, сложной настройки окружения и прочего.

На самом деле любители функционального программирования назовут еще несколько преимуществ чистых функций, более того, есть целые группы языков построенных полностью на чистоте (Haskell, Elm), но в этом уроке важны не сами чистые функции, а то, как их применять в реальных приложениях.

### Баланс между чистыми функциями и сайд-эффектами

Теоретически, мы можем построить полностью всё приложение на чистых функциях, но без сайд-эффектов мы не сможем загружать данные и показывать результат вычислений пользователю, значит необходимо совмещать оба подхода.

Идеальным подходом является организация кода таким образом, чтобы основная логика приложения была реализована с помощью чистых функций, а сайд-эффекты были изолированы и контролируемы. Этого можно достичь, путем создания цепочек чистых функций из которых мы сложим логику, тогда как сайд-эффекты будут на концах этих цепочек.

В реальности это будут скорее не цепочки, а древовидные графы, где чистые функции обрабатывают данные, а сайд-эффекты выполняются в строго определенных местах. В дальнейшем, мы разберемся как такое возможно и что нам дает effector.

## Управление внутренним состоянием

Состояние - ключевой элемент веб-приложения, оно определяет, как реагировать на события и когда обновлять интерфейс. Оно хранит данные, необходимые для работы приложения, такие как информация о пользователе, текущие настройки, ответ сервера или результаты вычислений.

### Что такое состояние?

Состояние может быть представлено в различных формах:

**Переменные в памяти**: всё что хранится в оперативной памяти приложения при определении let, var, const, аргументов функций, свойств объектов и так далее.

```ts
let clicksCount = 0;
const statistics = { leftClicks: 0, rightClicks: 0 };
```

**Data-атрибуты в DOM**: строки, хранящиеся непосредственно в DOM-элементах или даже в HTML.

```html
<div data-post-id="pWoEuPTKHYpK">...</div>
```

**Реактивные ячейки**: специальные структуры, автоматически отслеживающие изменения и распространяющие оповещения подписчикам.

```ts
const clickCount$ = new BehaviorSubject(0);
```

### Важность надежного управления состоянием

Правильное управление состоянием обеспечивает согласованность и предсказуемость поведения приложения. Существует множество способов управления состоянием, включая глобальные объекты, локальные переменные, потоки, ООП и прочее.

Каждый способ хранения состояния имеет свои плюсы и минусы. Например, хранение состояния в DOM может быть ненадежным, поскольку любое расширение браузера или другой код приложения может легко изменить DOM потеряв состояние.

Как разработчикам надежных приложений, нам хочется, чтобы состояние сложно было разрушить и при этом удобно им пользоваться.

### Эволюция подходов к управлению состоянием

Управление состоянием прошло путь от простых глобальных объектов до сложных библиотек, которые упрощают работу с состоянием, вводят понятие реактивности и отделяют бизнес-логику от интерфейса.

- **Flux**: Архитектура, предложенная Facebook, которая вводит однонаправленный поток данных. Сегодня не используется в чистом виде.
- **Redux**: Библиотека, реализующая и развивающая идеи Flux с акцентом на иммутабельность и чистые функции. В основном используется в рамках более комплексных решений вроде Redux Toolkit.
- **MobX**: Предлагает реактивный объектно-ориентированный подход к управлению состоянием. Лучше всего работает именно при использовании ООП парадигмы в JS приложениях, но стоит также ознакомиться и с [mobx-state-tree](https://npmjs.com/mobx-state-tree).
- **Effector**: Позволяет строить логику поверх трех основных примитивов, не нарушая границы архитектурных слоёв.

У каждого подхода помимо плюсов и минусов имеются границы применимости определяемые концепциями той или иной библиотеки.

## Реактивность и декларативность

**Реактивность** - это подход, при котором система автоматически реагирует на изменения данных. В контексте веб-приложений это означает, что изменение состояния автоматически приводит к обновлению интерфейса без необходимости явного указания, что и когда нужно обновить.

**Декларативное программирование** позволяет описывать, что должно быть сделано, а не как это сделать. В таких _фреймворках_, как React, Вы описываете желаемое состояние интерфейса, и фреймворк заботится о том, как его реализовать.

### Преимущества реактивности и декларативности

Использование реактивных подходов и декларативного программирования упрощает обновление интерфейса в ответ на изменения состояния:

Меньше кода требуется для описания логики приложения, так как распространением изменений занимается библиотека реактивных примитивов.

Код становится более понятным и легко поддерживаемым, так как императивное внесение изменений перекладывается на фреймворк (причем способов тоже достаточно много, сравните Angular, React, Solid, Svelte).

Меньше шансов забыть обновить интерфейс при изменении данных, ведь можно подписать интерфейс на обновление реактивной ячейки.

### Эволюция взаимодействия с сервером

Изначально веб-приложения взаимодействовали с сервером путем полной перезагрузки страниц. Пользователь нажимает на ссылку или отправляет форму, браузер переходит на другой URL, загружая весь HTML заново. С ростом сложности веб-сайтов, это приводило к длительному ожиданию ответа и как следствие плохому пользовательскому опыту.

С появлением технологий, таких как AJAX, появилась возможность выполнять асинхронные запросы к серверу без перезагрузки страницы. Это значительно улучшило UX и позволило создавать более интерактивные веб-приложения, такие как Gmail и Trello, одновременно с этим увеличило сложность кода.

### Современные тенденции

Сегодня наблюдается тенденция переносить больше логики на сервер:

- **Server Side Rendering**: Генерация HTML на стороне сервера с помощью JS-кода и браузерных технологий.
- **Serverless-архитектуры**: Выполнение отдельных функций на множестве распределенных серверов, без необходимости разворачивания своей инфраструктуры и процессов постоянно занимающих серверные мощности, то есть не платим за время простоя железа.
- **Edge computing**: Те же serverless-функции, но уже на серверах в регионе пользователя, например AWS Lambda Edge.
- **Гибридные методы:** можно совмещать серверный рендеринг с заранее собранными HTML-страницами, чтобы не выполнять конвертацию/сериализацию там, где нет динамики.
- **Islands:** Astro достиг невероятной оптимизации, когда научился разделять динамический код от полностью статичного, теперь можно заранее собрать HTML для всей страницы, оставив место для нескольких динамических островов, которые уже можно рендерить как в браузере, так и на сервере.

Баланс между клиентской и серверной логикой позволяет создавать быстрые и эффективные приложения, сохраняя при этом богатую функциональность на стороне браузера. Подход с серверной логикой не лишен проблем, например, используя Next.js и серверные компоненты невозможно сделать поддержку офлайн режима, потому что клиентский код обращается к серверу на каждое переключение страниц.

На самом деле, если не использовать серверные компоненты, то конечно можно сделать офлайн на Next.js, а еще можно часть серверного кода выполнять в отдельном потоке Service Worker, например рендеринг серверных компонентов, что также позволит реализовать поддержку работы в офлайн режиме с последующей синхронизацией.

### Три столпа любого приложения

Любое приложение строится на основе трех основных элементов

- **События**: Инициируют действия в приложении.
- **Состояние**: Хранит данные и определяет текущее состояние приложения.
- **Сайд-эффекты**: Взаимодействуют с внешним миром и изменяют окружение.

### Пример последовательности

1. После загрузки приложения генерируется событие appStarted.
2. Это событие может инициировать сайд-эффект - загрузку данных о текущем пользователе.
3. Полученные данные сохраняются в состоянии.
4. Изменение состояния приводит к обновлению интерфейса или генерирует новые события.

```txt
1. appStarted
2. loadUserData
3. loadUserData finished
4. userDataUpdated
```

### Динамика приложения

Важно помнить, что браузер пользователя не останавливается во время выполнения запросов к серверу. Пользователь может перезагрузить страницу, выполнить клиентский переход кликом по ссылке или нажатием кнопки “Назад” в браузере. Поэтому приложение должно быть устойчивым к таким изменениям и правильно обрабатывать асинхронные операции выполняемые в фоне, события и обновления состояния.

## Заключение

События, состояние и сайд-эффекты являются фундаментальными элементами любого веб-приложения. Хоть фреймворки и оборачивают элементы в свои специфичные обертки, оперировать приходится в тех же условиях.

Понимание и правильное использование этих концепций позволяет создавать приложения, которые:

- **Отзывчивы**: быстро реагируют на действия пользователя и изменения в данных;
- **Надежны**: предсказуемо ведут себя в различных ситуациях, так как сайд-эффекты изолированы;
- **Масштабируемы**: относительно легко расширяются и модифицируются.

Изоляция сайд-эффектов и использование чистых функций повышает надежность кода, упрощает его поддержку и написание тестов. Управление состоянием с помощью современных подходов, таких как effector или MobX, упрощает работу с состоянием и отделяет бизнес-логику от интерфейса.

В следующих уроках мы рассмотрим, как **effector** использует события, сайд-эффекты и состояние для описания логики веб-приложений. Мы детально разберем примеры и покажем, как применять эти концепции на практике.

## Что еще почитать

[Принципы функционального программирования в JavaScript](https://habr.com/ru/companies/ruvds/articles/434112/)
